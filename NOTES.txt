#! Refer => https://www.youtube.com/playlist?list=PLC3y8-rFHvwjOKd6gdf4QtV1uYNiQnruI

#? Next.js 14 Tutorial - 2 - Hello World
1. Create a new project using => npx create-next-app@latest
2. Accept all the default values except the aliasing asked at the end

#? Next.js 14 Tutorial - 3 - Project Structure
1. package.json => all packages and dependencies
2. next.config.mjs => next config
3. tsconfig.json => typescript config
4. .eslintrc.js => eslint config
5. tailwind.config.ts => tailwindcss config
6. postcss.config.mjs => tailwindcss & postcss config
7. node_modules => node_modules
8. public => static assets (e.g. images, files, etc.)
9. src/app => application folder
10. src/app/globals.css => global styles
11. src/app/layout.tsx => UI which can be shared across all pages of your application
12. arc/app/page.tsx => unique UI we see when we visit localhost:3000

#? Next.js 14 Tutorial - 4 - Before we start   

In React 18, the concept of RSC (React Server Components) was introduced. This feature was quickly adopted by Next.js.

There are 2 types of components in Next.js:
a) Server components
b) Client components

-- Server components
* In next.js, all components are server components by default
* They have the ability to run tasks like reading files or fetching data from the server.
* However, they do not have the ability to use hooks or handle user interaction.

-- Client components
* To create a client component, it is necessary to add "use client" at the top of the component file.
* Client components are used for UI components that are only rendered on the client-side.
* Client components cannot perform tasks like reading files or fetching data from the server but they have the ability to use hooks and manager user interaction.
* Client components are the traditional react components which we are familiar with and have used in the past prior react apps.

-- React Server Components and Routing

* We'll explore examples where we use server components that await certain actions to finalize before rendering content on the screen.
* We'll also see examples where we use client components to leverage hooks from the routing module.

#? Next.js 14 Tutorial - 5 - Routing

* Next.js has a file-system based routing mechanism.
* URL paths that users can access in the browser are defined by files and folders in your codebase.

-- Routing Conventions

* All routes must be placed inside the app folder.
* Every file that corresponds to a route must be named page.js or page.tsx.
* Every folder corresponds to a path segment in the browser URL.
* Example 
=> src/app/page.js is linked to http://localhost:3000/
=> src/app/about/page.js is linked to http://localhost:3000/about
=> src/app/profile/page.js is linked to http://localhost:3000/profile

1. Now delete the app directory in the src as we will be learning routing by creating a new one ourselves.
2. In the src directory, create a new directory called app.
3. In the app directory, create a new file called pages.tsx
"
export default function Home() {
  return (
    <html>
      <body>
        <h1>Hello World!</h1>
      </body>
    </html>
  );
}
"
4. Now run the server using "npm run dev"
5. Have a layout.tsx file too which will contain details like meta data, links, scripts, etc. This file is automatically generated by Next.js.

* If in the browser, you visit about to which is not a valid page, then Next.js will automatically show a 404 page. 

#? Next.js 14 Tutorial - 6 - Nested Routes

* Static nested routes implementation
* Create folder inside folder for nested routes. Each folder will be a page so add a page.js or page.tsx file in it.

#? Next.js 14 Tutorial - 7 - Dynamic Routes

* Dynamic routes implementation
* Inside the src/app directory, create a new folder called products and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/"
* Now inside the products folder, create a new folder called [productId] and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]" where [productId] is a dynamic route so we can add any value to it. Example => "localhost:3000/products/1" , "localhost:3000/products/2" etc.
* This is possible because Next.js treats folders with [] as dynamic routes.

* Now we can also use the params to generate dynamic text or data related to it.

** [productId]/page.tsx ** Version 1
"
export default function ProductDetails({params}) {
    return <h1>Details about the product {params.productId}</h1>;
}
"

Error: 1 - error TS2322: Type 'any' is not assignable to type 'string'.

** [productId]/page.tsx ** Version 2 (After fixing the TS error stating that params has type 'any')
"
interface Props {
  productId: string;
}

export default function ProductDetails(props: Props) {
  return <h1>Details about the product {props.productId}</h1>;
}
"

or 

"
export default function ProductDetails({params}: {params: {productId: string}}) {
  return <h1>Details about the product {params.productId}</h1>;
}
"

Error : 2 
"
âœ“ Compiled /products/[productId] in 124ms
Error: Route "/products/[productId]" used `params.productId`. `params` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis
    at createParamsAccessError (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:467:9)
    at getMessage (turbopack://[project]/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts:46:20)
    at warnForSyncAccess (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:445:4)
    at syncIODev (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:403:10)
    at ProductDetails (turbopack://[project]/src/app/products/[productId]/page.tsx:2:49)
  1 | export default function ProductDetails({params}: {params: {productId: string}}) {
> 2 |     return <h1>Details about the product {params.productId}</h1>;
    |                                                 ^
  3 | }
"

** [productId]/page.tsx ** Version 3 (After fixing the async await error)
"
export default async function ProductDetails({params}: {params: {productId: string}}) {
    const {productId} = await params
    return <h1>Details about the product {productId}</h1>;
}
"