#! Refer => https://www.youtube.com/playlist?list=PLC3y8-rFHvwjOKd6gdf4QtV1uYNiQnruI

#? Next.js 14 Tutorial - 2 - Hello World
1. Create a new project using => npx create-next-app@latest
2. Accept all the default values except the aliasing asked at the end

#? Next.js 14 Tutorial - 3 - Project Structure
1. package.json => all packages and dependencies
2. next.config.mjs => next config
3. tsconfig.json => typescript config
4. .eslintrc.js => eslint config
5. tailwind.config.ts => tailwindcss config
6. postcss.config.mjs => tailwindcss & postcss config
7. node_modules => node_modules
8. public => static assets (e.g. images, files, etc.)
9. src/app => application folder
10. src/app/globals.css => global styles
11. src/app/layout.tsx => UI which can be shared across all pages of your application
12. arc/app/page.tsx => unique UI we see when we visit localhost:3000

#? Next.js 14 Tutorial - 4 - Before we start   

In React 18, the concept of RSC (React Server Components) was introduced. This feature was quickly adopted by Next.js.

There are 2 types of components in Next.js:
a) Server components
b) Client components

-- Server components
* In next.js, all components are server components by default
* They have the ability to run tasks like reading files or fetching data from the server.
* However, they do not have the ability to use hooks or handle user interaction.

-- Client components
* To create a client component, it is necessary to add "use client" at the top of the component file.
* Client components are used for UI components that are only rendered on the client-side.
* Client components cannot perform tasks like reading files or fetching data from the server but they have the ability to use hooks and manager user interaction.
* Client components are the traditional react components which we are familiar with and have used in the past prior react apps.

-- React Server Components and Routing

* We'll explore examples where we use server components that await certain actions to finalize before rendering content on the screen.
* We'll also see examples where we use client components to leverage hooks from the routing module.

#? Next.js 14 Tutorial - 5 - Routing

* Next.js has a file-system based routing mechanism.
* URL paths that users can access in the browser are defined by files and folders in your codebase.

-- Routing Conventions

* All routes must be placed inside the app folder.
* Every file that corresponds to a route must be named page.js or page.tsx.
* Every folder corresponds to a path segment in the browser URL.
* Example 
=> src/app/page.js is linked to http://localhost:3000/
=> src/app/about/page.js is linked to http://localhost:3000/about
=> src/app/profile/page.js is linked to http://localhost:3000/profile

1. Now delete the app directory in the src as we will be learning routing by creating a new one ourselves.
2. In the src directory, create a new directory called app.
3. In the app directory, create a new file called pages.tsx
"
export default function Home() {
  return (
    <html>
      <body>
        <h1>Hello World!</h1>
      </body>
    </html>
  );
}
"
4. Now run the server using "npm run dev"
5. Have a layout.tsx file too which will contain details like meta data, links, scripts, etc. This file is automatically generated by Next.js.

* If in the browser, you visit about to which is not a valid page, then Next.js will automatically show a 404 page. 

#? Next.js 14 Tutorial - 6 - Nested Routes

* Static nested routes implementation
* Create folder inside folder for nested routes. Each folder will be a page so add a page.js or page.tsx file in it.

#? Next.js 14 Tutorial - 7 - Dynamic Routes

* Dynamic routes implementation
* Inside the src/app directory, create a new folder called products and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/"
* Now inside the products folder, create a new folder called [productId] and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]" where [productId] is a dynamic route so we can add any value to it. Example => "localhost:3000/products/1" , "localhost:3000/products/2" etc.
* This is possible because Next.js treats folders with [] as dynamic routes.

* Now we can also use the params to generate dynamic text or data related to it.

** [productId]/page.tsx ** Version 1
"
export default function ProductDetails({params}) {
    return <h1>Details about the product {params.productId}</h1>;
}
"

Error: 1 - error TS2322: Type 'any' is not assignable to type 'string'.

** [productId]/page.tsx ** Version 2 (After fixing the TS error stating that params has type 'any')
"
interface Props {
  productId: string;
}

export default function ProductDetails(props: Props) {
  return <h1>Details about the product {props.productId}</h1>;
}
"

or 

"
export default function ProductDetails({params}: {params: {productId: string}}) {
  return <h1>Details about the product {params.productId}</h1>;
}
"

Error : 2 
"
âœ“ Compiled /products/[productId] in 124ms
Error: Route "/products/[productId]" used `params.productId`. `params` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis
    at createParamsAccessError (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:467:9)
    at getMessage (turbopack://[project]/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts:46:20)
    at warnForSyncAccess (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:445:4)
    at syncIODev (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:403:10)
    at ProductDetails (turbopack://[project]/src/app/products/[productId]/page.tsx:2:49)
  1 | export default function ProductDetails({params}: {params: {productId: string}}) {
> 2 |     return <h1>Details about the product {params.productId}</h1>;
    |                                                 ^
  3 | }
"

** [productId]/page.tsx ** Version 3 (After fixing the async await error)
"
export default async function ProductDetails({params}: {params: {productId: string}}) {
    const {productId} = await params
    return <h1>Details about the product {productId}</h1>;
}
"

#? Next.js 14 Tutorial - 8 - Nested Dynamic Routes

* Nested dynamic routes implementation
* Inside the src/app/[productId] directory, create a new folder called reviews and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]/reviews/"
* Inside src/app/[productId]/reviews/[reviewId] folder, add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]/reviews/[reviewId]" where [productId] and [reviewId] are dynamic routes so we can add any value to it. Example => "localhost:3000/products/1/reviews/1" , "localhost:3000/products/1/reviews/2" etc.
* This is possible because Next.js treats folders with [] as dynamic routes.

** [productId]/reviews/[reviewId]/page.tsx ** 
"
export default async function ReviewDetails({params}: {params: {productId: string;reviewId: string}}) {
    const {productId, reviewId} = await params
    return <h1>Details about the review {reviewId} from product {productId}</h1>;
}
"

#? Next.js 14 Tutorial - 9 - Catch all Segments

* Catch all segments implementation
* Inside the src/app directory, create a new folder called docs, then inside it a new folder called [...slug] and add a page.tsx file in it. With this we will get a page for "localhost:3000/docs/[...slug]" where [...slug] is a catch-all segment.
** [...slug]/page.tsx **
"
export default async function Docs({params}: {params: {slug: string[]}}) {
    const {slug} = await params
    if (slug.length === 2) {
      return <h1>Viewing docs for feature {slug[0]} and concept {slug[1]}</h1>
    } 
    else if (slug.length === 1) {
      return <h1>Viewing docs for feature {slug[0]}</h1>;
    }
    else
    {
        return <h1>Docs Home Page</h1>;
    }
}
"

#? Next.js 14 Tutorial - 10 - Not Found Page

* If in the browser, you visit about to which is not a valid page, then Next.js will automatically show a 404 page.
* In src/app directory, create a new file called not-found.tsx. This NotFound() will be for overall application.
* For specific pages, create a new file called not-found.tsx inside that specific folder. This NotFound() will be for that specific page. Refer to src/app/products/[productId]/reviews/[reviewId]/not-found.tsx

#? Next.js 14 Tutorial - 11 - File Colocation

* So in summary the folder needs to have a page.tsx or it won't work and you can create a separate component to keep your reusable components.

#? Next.js 14 Tutorial - 12 - Private Routes

* A private folder indicates that it is a private implementation detail and should not be considered by the routing system.
* The folder and all its subfolders are excluded from routing.
* Prefix the folder name with an underscore. 

* Best to create util functions here.

* For separating UI logic from routing logic
* For consistently organizing internal files across a project
* For sorting and grouping files in code editors
* And finally, for avoiding potential naming conflicts with future Next.js file conventions
* If you want to include an underscore in URL segments, you can prefix the folder name with "%5F," which is the URL-encoded form of an underscore

* Rather than "_lib", use "%5Flib" to view the private route in the browser as "%5F" is equivalent to "_"

#? Next.js 14 Tutorial - 13 - Route Groups

* Allows us to logically group our routes and project files without affecting the URL path structure

**Let's implement authentication routes**

* Register
* Login
* Forgot password

#! Approach - 1 (Messy and Not feasible)
* Create new folders called "login", "register" and "forgot-password" with a page.tsx in each of them.
* This approach is unorganized and any new developer may not know which folder to look at.
* Example url => http://localhost:3000/login

#! Approach - 2 (Feasible but gets the auth name in the URL)
* Create new folder called "auth" with a page.tsx in it.
* Move the above 3 folders into the "auth" folder.
* Example url => http://localhost:3000/auth/login

#! Approach - 3 (Best as it does not get the auth name in the URL)
* Rather than naming the folder "auth", make it "(auth)"
* This will omit the folder name i.e auth from the URL.
* Example url => http://localhost:3000/login

#? Next.js 14 Tutorial - 14 - Layouts

* A page is UI that is unique to a route
* A layout is UI that is shared between multiple pages in the app

How to Create Layouts?

* You can define a layout by default exporting a React component from a layout.js or layout.tsx file.
* That component should accept a children prop that will be populated with a child page during rendering.

* Observe the default layout.tsx file in src/app directory.

#? Next.js 14 Routing - 15 - Nested Layouts

* You can create layout for a specific page/route by creating a layout.tsx inside that specific folder.
* Create a layout.tsx at src/app/products/[productId]/layout.tsx

Execution Order => First the app's layout.tsx gets rendered and as we go to products/[productId], the children of the main layout gets replaced with the products/[productId] layout.tsx and so on.

#? Next.js 14 Tutorial - 16 - Route Group Layout

Uses:
* To organize your project in a manner that does not affect the url
* To selectively apply a layout to certain segments while leaving others unchanged 

* Refer to src/app/(auth)/(with-auth-layout) folder

#? Next.js 14 Tutorial - 17 - Routing Metadata

* You can set metadata in the layout.tsx or page.tsx