#! Refer => https://www.youtube.com/playlist?list=PLC3y8-rFHvwjOKd6gdf4QtV1uYNiQnruI

#? Next.js 14 Tutorial - 2 - Hello World
1. Create a new project using => npx create-next-app@latest
2. Accept all the default values except the aliasing asked at the end

#? Next.js 14 Tutorial - 3 - Project Structure
1. package.json => all packages and dependencies
2. next.config.mjs => next config
3. tsconfig.json => typescript config
4. .eslintrc.js => eslint config
5. tailwind.config.ts => tailwindcss config
6. postcss.config.mjs => tailwindcss & postcss config
7. node_modules => node_modules
8. public => static assets (e.g. images, files, etc.)
9. src/app => application folder
10. src/app/globals.css => global styles
11. src/app/layout.tsx => UI which can be shared across all pages of your application
12. arc/app/page.tsx => unique UI we see when we visit localhost:3000

#? Next.js 14 Tutorial - 4 - Before we start   

In React 18, the concept of RSC (React Server Components) was introduced. This feature was quickly adopted by Next.js.

There are 2 types of components in Next.js:
a) Server components
b) Client components

-- Server components
* In next.js, all components are server components by default
* They have the ability to run tasks like reading files or fetching data from the server.
* However, they do not have the ability to use hooks or handle user interaction.

-- Client components
* To create a client component, it is necessary to add "use client" at the top of the component file.
* Client components are used for UI components that are only rendered on the client-side.
* Client components cannot perform tasks like reading files or fetching data from the server but they have the ability to use hooks and manager user interaction.
* Client components are the traditional react components which we are familiar with and have used in the past prior react apps.

-- React Server Components and Routing

* We'll explore examples where we use server components that await certain actions to finalize before rendering content on the screen.
* We'll also see examples where we use client components to leverage hooks from the routing module.

#? Next.js 14 Tutorial - 5 - Routing

* Next.js has a file-system based routing mechanism.
* URL paths that users can access in the browser are defined by files and folders in your codebase.

-- Routing Conventions

* All routes must be placed inside the app folder.
* Every file that corresponds to a route must be named page.js or page.tsx.
* Every folder corresponds to a path segment in the browser URL.
* Example 
=> src/app/page.js is linked to http://localhost:3000/
=> src/app/about/page.js is linked to http://localhost:3000/about
=> src/app/profile/page.js is linked to http://localhost:3000/profile

1. Now delete the app directory in the src as we will be learning routing by creating a new one ourselves.
2. In the src directory, create a new directory called app.
3. In the app directory, create a new file called pages.tsx
"
export default function Home() {
  return (
    <html>
      <body>
        <h1>Hello World!</h1>
      </body>
    </html>
  );
}
"
4. Now run the server using "npm run dev"
5. Have a layout.tsx file too which will contain details like meta data, links, scripts, etc. This file is automatically generated by Next.js.

* If in the browser, you visit about to which is not a valid page, then Next.js will automatically show a 404 page. 

#? Next.js 14 Tutorial - 6 - Nested Routes

* Static nested routes implementation
* Create folder inside folder for nested routes. Each folder will be a page so add a page.js or page.tsx file in it.

#? Next.js 14 Tutorial - 7 - Dynamic Routes

* Dynamic routes implementation
* Inside the src/app directory, create a new folder called products and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/"
* Now inside the products folder, create a new folder called [productId] and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]" where [productId] is a dynamic route so we can add any value to it. Example => "localhost:3000/products/1" , "localhost:3000/products/2" etc.
* This is possible because Next.js treats folders with [] as dynamic routes.

* Now we can also use the params to generate dynamic text or data related to it.

** [productId]/page.tsx ** Version 1
"
export default function ProductDetails({params}) {
    return <h1>Details about the product {params.productId}</h1>;
}
"

Error: 1 - error TS2322: Type 'any' is not assignable to type 'string'.

** [productId]/page.tsx ** Version 2 (After fixing the TS error stating that params has type 'any')
"
interface Props {
  productId: string;
}

export default function ProductDetails(props: Props) {
  return <h1>Details about the product {props.productId}</h1>;
}
"

or 

"
export default function ProductDetails({params}: {params: {productId: string}}) {
  return <h1>Details about the product {params.productId}</h1>;
}
"

Error : 2 
"
✓ Compiled /products/[productId] in 124ms
Error: Route "/products/[productId]" used `params.productId`. `params` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis
    at createParamsAccessError (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:467:9)
    at getMessage (turbopack://[project]/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts:46:20)
    at warnForSyncAccess (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:445:4)
    at syncIODev (turbopack://[project]/node_modules/next/dist/src/server/request/params.ts:403:10)
    at ProductDetails (turbopack://[project]/src/app/products/[productId]/page.tsx:2:49)
  1 | export default function ProductDetails({params}: {params: {productId: string}}) {
> 2 |     return <h1>Details about the product {params.productId}</h1>;
    |                                                 ^
  3 | }
"

** [productId]/page.tsx ** Version 3 (After fixing the async await error)
"
export default async function ProductDetails({params}: {params: {productId: string}}) {
    const {productId} = await params
    return <h1>Details about the product {productId}</h1>;
}
"

#? Next.js 14 Tutorial - 8 - Nested Dynamic Routes

* Nested dynamic routes implementation
* Inside the src/app/[productId] directory, create a new folder called reviews and add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]/reviews/"
* Inside src/app/[productId]/reviews/[reviewId] folder, add a page.tsx file in it. With this we will get a page for "localhost:3000/products/[productId]/reviews/[reviewId]" where [productId] and [reviewId] are dynamic routes so we can add any value to it. Example => "localhost:3000/products/1/reviews/1" , "localhost:3000/products/1/reviews/2" etc.
* This is possible because Next.js treats folders with [] as dynamic routes.

** [productId]/reviews/[reviewId]/page.tsx ** 
"
export default async function ReviewDetails({params}: {params: {productId: string;reviewId: string}}) {
    const {productId, reviewId} = await params
    return <h1>Details about the review {reviewId} from product {productId}</h1>;
}
"

#? Next.js 14 Tutorial - 9 - Catch all Segments

* Catch all segments implementation
* Inside the src/app directory, create a new folder called docs, then inside it a new folder called [...slug] and add a page.tsx file in it. With this we will get a page for "localhost:3000/docs/[...slug]" where [...slug] is a catch-all segment.
** [...slug]/page.tsx **
"
export default async function Docs({params}: {params: {slug: string[]}}) {
    const {slug} = await params
    if (slug.length === 2) {
      return <h1>Viewing docs for feature {slug[0]} and concept {slug[1]}</h1>
    } 
    else if (slug.length === 1) {
      return <h1>Viewing docs for feature {slug[0]}</h1>;
    }
    else
    {
        return <h1>Docs Home Page</h1>;
    }
}
"

#? Next.js 14 Tutorial - 10 - Not Found Page

* If in the browser, you visit about to which is not a valid page, then Next.js will automatically show a 404 page.
* In src/app directory, create a new file called not-found.tsx. This NotFound() will be for overall application.
* For specific pages, create a new file called not-found.tsx inside that specific folder. This NotFound() will be for that specific page. Refer to src/app/products/[productId]/reviews/[reviewId]/not-found.tsx

#? Next.js 14 Tutorial - 11 - File Colocation

* So in summary the folder needs to have a page.tsx or it won't work and you can create a separate component to keep your reusable components.

#? Next.js 14 Tutorial - 12 - Private Routes

* A private folder indicates that it is a private implementation detail and should not be considered by the routing system.
* The folder and all its subfolders are excluded from routing.
* Prefix the folder name with an underscore. 

* Best to create util functions here.

* For separating UI logic from routing logic
* For consistently organizing internal files across a project
* For sorting and grouping files in code editors
* And finally, for avoiding potential naming conflicts with future Next.js file conventions
* If you want to include an underscore in URL segments, you can prefix the folder name with "%5F," which is the URL-encoded form of an underscore

* Rather than "_lib", use "%5Flib" to view the private route in the browser as "%5F" is equivalent to "_"

#? Next.js 14 Tutorial - 13 - Route Groups

* Allows us to logically group our routes and project files without affecting the URL path structure

**Let's implement authentication routes**

* Register
* Login
* Forgot password

#! Approach - 1 (Messy and Not feasible)
* Create new folders called "login", "register" and "forgot-password" with a page.tsx in each of them.
* This approach is unorganized and any new developer may not know which folder to look at.
* Example url => http://localhost:3000/login

#! Approach - 2 (Feasible but gets the auth name in the URL)
* Create new folder called "auth" with a page.tsx in it.
* Move the above 3 folders into the "auth" folder.
* Example url => http://localhost:3000/auth/login

#! Approach - 3 (Best as it does not get the auth name in the URL)
* Rather than naming the folder "auth", make it "(auth)"
* This will omit the folder name i.e auth from the URL.
* Example url => http://localhost:3000/login

#? Next.js 14 Tutorial - 14 - Layouts

* A page is UI that is unique to a route
* A layout is UI that is shared between multiple pages in the app

How to Create Layouts?

* You can define a layout by default exporting a React component from a layout.js or layout.tsx file.
* That component should accept a children prop that will be populated with a child page during rendering.

* Observe the default layout.tsx file in src/app directory.

#? Next.js 14 Routing - 15 - Nested Layouts

* You can create layout for a specific page/route by creating a layout.tsx inside that specific folder.
* Create a layout.tsx at src/app/products/[productId]/layout.tsx

Execution Order => First the app's layout.tsx gets rendered and as we go to products/[productId], the children of the main layout gets replaced with the products/[productId] layout.tsx and so on.

#? Next.js 14 Tutorial - 16 - Route Group Layout

Uses:
* To organize your project in a manner that does not affect the url
* To selectively apply a layout to certain segments while leaving others unchanged 

* Refer to src/app/(auth)/(with-auth-layout) folder

#? Next.js 14 Tutorial - 17 - Routing Metadata

* You can set metadata in the layout.tsx or page.tsx

#? Next.js 14 Tutorial - 18 - title Metadata

** layout.tsx **
"
export const metadata: Metadata = {
  title: {
    default: "Next.js",
    absolute: "",
    template: "%s | Next.js",
  },
  description: "Generated by create next app",
};
"

#? Next.js 14 Tutorial - 19 - Link Component Navigation

* Use link component from next/link in the layout.tsx or page.tsx
* refer to src/app/products/[productId]/layout.tsx

#? Next.js 14 Tutorial - 20 - Active Links

* Create a layout.tsx in the (auth) folder.
** layout.tsx **
"
"use client";
import Link from "next/link";
import { usePathname } from "next/navigation";
import "./styles.css";

const navLinks = [
    { name: "Login", href: "/login" },
    { name: "Register", href: "/register" },
    { name: "Forgot Password", href: "/forgot-password" },
];

export default function AuthLayout({ children }: { children: React.ReactNode }) {
    const pathname = usePathname();
    
    return (
        <div>
            <h1>Auth Layout</h1>
            <ul>
                {navLinks.map((link) => {
                    const isActive = pathname.startsWith(link.href);
                    return (
                        <li key={link.href}>
                            <Link href={link.href} className={isActive ? "font-bold mr-4" : "text-blue-500"}>
                                {link.name}
                            </Link>
                        </li>
                    );
                })}
            </ul>
            {children}
        </div>
    );
}
"

#? Next.js 14 Tutorial - 21 - Navigating Programmatically

* Create a new route by creating a folder named "order-product" and a page.tsx in it.
** page.tsx **
"
"use client";

import { useRouter } from "next/navigation";

export default function OrderProduct() {
  const router = useRouter();

  const handleClick = () => {
    console.log("Order Placed");
    router.push("/");
  };

  return (
    <>
      <h1>Order Product</h1>
      <button onClick={handleClick}>Place Order</button>
    </>
  );
}
"

#? Next.js 14 Tutorial - 22 - Templates

* In layout.tsx, if you use state management, when you route to a new page, the state is preserved and does not change or reset.
* But in template.tsx, if you use state management, when you route to a new page, the state is reset.

** src/app/(auth)/layout.tsx  which is not renamed to template.tsx **
"
"use client";
import Link from "next/link";
import { usePathname } from "next/navigation";
import "./styles.css";
import {useState} from "react";

const navLinks = [
    { name: "Login", href: "/login" },
    { name: "Register", href: "/register" },
    { name: "Forgot Password", href: "/forgot-password" },
];

export default function AuthLayout({ children }: { children: React.ReactNode }) {
    const pathname = usePathname();
    const [input, setInput] = useState('');
    
    return (
        <div>
            <div>
                <input
                    type="text"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    style={{border: '1px solid black'}}
                />
            </div>
            <h1>Auth Layout</h1>
            <ul>
                {navLinks.map((link) => {
                    const isActive = pathname.startsWith(link.href);
                    return (
                        <li key={link.href}>
                            <Link href={link.href} className={isActive ? "font-bold mr-4" : "text-blue-500"}>
                                {link.name}
                            </Link>
                        </li>
                    );
                })}
            </ul>
            {children}
        </div>
    );
}
"

#? Next.js 14 Tutorial - 23 - Loading UI

* Allows creating loading states for route segments
* Loading state appears immediately upon navigation
* Provides assurance of responsiveness and active content loading

* Create a loading.tsx at the src/app/blog/loading.tsx
"
export default function Loading() {
    return <h1>Loading...</h1>;
}
"

* You can display the loading state as soon as a user navigates to a new route
* The immediate feedback reassures users that their action has been acknowledged
* Reduces perceived loading times
* Makes the application feel more responsive
* Next.js allows the creation of shared layouts that remain interactive while new route segments are loading
* Users can continue interacting with certain parts of the application, such as a navigation menu or sidebar, even if the main content is still being fetched

#? PS D:\Next.js Tutorial Codevolution\24. Next.js 14 Tutorial - 24 - Error Handling>

#! Approach 1 - Write code to throw error on specific condition
* Make changes in src/app/products/reviews/[reviewId]/page.tsx
"
import {notFound} from 'next/navigation'

function getRandomInt(count: number) {
    return Math.floor(Math.random() * count)    
}

export default async function ReviewDetails({params}: {params: {productId: string; reviewId: string}}) {
    const {productId, reviewId} = await params

    const random = getRandomInt(5);
    console.log(random);

    if (random > 1) {
        throw new Error('Something went wrong. Error loading review. Error code: 500')
    }

    if (parseInt(reviewId) > 10) {
        notFound()
    }

    return <h1>Details about the review {reviewId} from product {productId}</h1>;
}
"

#! Approach 2 - Create a new file named error.tsx. This will catch the error messgae and show it in the page rather than throwing an error
"
"use client";

export default function ErrorBoundary({ error }: { error: Error }) {
    return (
        <div>
            {/* <h2>ErrorBoundary: Error in Review</h2> */}
            <p>{error.message}</p>
        </div>
    );
}
"

#? Next.js 14 Tutorial - 25 - Recovering from Errors
** src/app/products/[productId]/reviews/[reviewId]/error.tsx **
"
"use client";

export default function ErrorBoundary({ error, reset }: { error: Error; reset: () => void }) {
    return (
        <div>
            {/* <h2>ErrorBoundary: Error in Review</h2> */}
            <p>{error.message}</p>
            <button onClick={reset}>Try Again</button>
        </div>
    );
}
"

* Executing the reset function will reload/rerender the page, if successful then contents of page.tsx will be re-rendered and shown else error message will be shown

#? Next.js 14 Tutorial - 26 - Handling Errors in Nested Routes

* Errors bubble up to the closest parent error boundary.
* An error.tsx file will cater to errors for all its nested child segments.
* By positioning error.tsx files at different levels in the nested folders of a route, you can achieve a more granular level of error handling.

#? Next.js 14 Tutorial - 27 - Handling Errors in Layouts

* error.tsx and layout.tsx should be on same level in the folder structure in a directory

#? Next.js 14 Tutorial - 28 - Parallel Routes

* Check the scenario in the IMAGES folder

* Create a new folder named "complex-dashboard" and inside create a layout.tsx and page.tsx file

#! Approach 1 (Traditional Method)
** page.tsx **
"
export default function ComplexDashboardPage() {
    return (
        <h1>Complex Dashboard Page</h1>
    )
}
"

** layout.tsx **
"
import UserAnalytics from "@/components/UserAnalytics";
import RevenueMetrics from "@/components/RevenueMetrics";
import Notifications from "@/components/Notifications";

export default function DashboardLayout({
    children
}: {
    children: React.ReactNode
}) {
    return (
        <>
            <div>{children}</div> {/* Content from page.tsx */}
            <UserAnalytics /> {/* User Analytics component */}
            <RevenueMetrics /> {/* Revenue Metrics component */}
            <Notifications /> {/* Notifications component */}
        </>
    )
}
"

#! Approach 2 (Using "@folder_name" slots)
* We will create slots for Parallel Routes using "@folder_name" with page.tsx in each of it.
* We will create "@notifications" folder inside "@complex-dashboard" folder with a page.tsx file
** page.tsx **
"
export default function Notifications() {
    return (
        <h1>Notifications</h1>
    )
}
"
* Similarly create "@revenue" and "@users" folder with a page.tsx file
* Create a components folder in src directory and create a card component.
** card.tsx **
"
const Card = ({children}: {children: React.ReactNode}) => {
    const cardStyle = {
        padding: "100px",
        margin: "10px",
        boxShadow: "0 0 15px rgba(0, 0, 0, 0.1)",
        border: "1px solid f0f0f0",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
    };

    return <div style={cardStyle}>{children}</div>;
}

export default Card;
"

** notifications/page.tsx **
"
import Card from "@/components/card";

export default function Notifications() {
  return <Card>Notifications</Card>;
}
"

** complex-dashboard/layout.tsx **
"
export default function DashboardLayout({
    children,
    users,
    revenue,
    notifications
}: {
    children: React.ReactNode,
    users: React.ReactNode,
    revenue: React.ReactNode,
    notifications: React.ReactNode
}) {
    return (
        <>
            <div>{children}</div> {/* Content from page.tsx */}
            <div style={{ display: "flex" }}>
                <div style={{ display: "flex", flexDirection: "column" }}>
                    <div>{users}</div>
                    <div>{revenue}</div>
                </div>
                <div style={{ display: "flex", flex: 1 }}>{notifications}</div>
            </div>
        </>
    )
}
"

#? Next.js 14 Tutorial - 29 - Unmatched Routes

* Refer images
* Create a archived folder with page.tsx inside a slot i.e @folder_name
* Also create a default.tsx in the parent folder and the child folder i.e the slots folders to have a fallback page for unmatched routes

#? Next.js 14 Tutorial - 30 - Conditional Routes

* render page according to the condition if ifLoggedIn is true, then show the page else show the login page

#? Next.js 14 Tutorial - 31 - Intercepting Routes

* The name of the folder should be "(.)folder_name" with a page.tsx
* The page will be shown at the first time the user visits the route/page, and after reloading it will show te regular page from "folder_name"
* Check Images to know more about (.), (..) and (...)

#? Next.js 14 Tutorial - 32 - Parallel Intercepting Routes

* To be covered later

#? Next.js 14 Tutorial - 33 - Route Handlers

* Route handlers are used to handle the request and response of a route.
* Check the IMAGES folder

* Always create a route folder with a page.tsx file in it. Then inside that route folder, create a api folder with route.ts file in it.

#? Next.js 14 Tutorial - 34 - Handling GET Request

* Create a folder named "comments" and inside it create a data.ts file and a route.tsx file.
* Make a api request to the route and get the response.

#? Next.js 14 Tutorial - 35 - Handling POST Request

* In the route.tsx file, make a POST request to the route and get the response.

#? Next.js 14 Tutorial - 36 - Dynamic Route Handlers

* Create a "[id]" folder inside the comments folder/route with a route.tsx file.
** route.tsx **
"
import { comments } from "../data";

export async function GET(request: Request, { params }: { params: { id: string } }) {
    const { id } = await params;
    const comment = comments.find((comment) => comment.id === parseInt(id));
    return new Response(JSON.stringify(comment), { status: 200 });
}
"

#? Next.js 14 Tutorial - 37 - Handling PATCH Request

* In the route.tsx file in the [id] folder, make a PATCH request to the route and get the response.
** route.tsx **
"
export async function PATCH(request: Request, { params }: { params: { id: string } }) {
    const { id } = await params;
    const body = await request.json();
    const { text } = body;
    const index = comments.findIndex((comment) => comment.id === parseInt(id));
    comments[index].text = text;

    return new Response(JSON.stringify(comments[index]), { status: 200 });
}
"

#? Next.js 14 Tutorial - 38 - Handling DELETE Request

** route.tsx **
"
export async function DELETE(request: Request, { params }: { params: { id: string } }) {
    const { id } = await params;
    const index = comments.findIndex((comment) => comment.id === parseInt(id));
    const deletedComment = comments[index];
    comments.splice(index, 1);
    return new Response(JSON.stringify(deletedComment), { status: 204 });
}
"

#? Next.js 14 Tutorial - 39 - URL Query Parameters

** route.tsx **
"
export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get("query");
    const filteredComments = query ? comments.filter((comment) => comment.text.includes(query)) : comments;
  
    return new Response(JSON.stringify(filteredComments), { status: 200 });
}
"

#? Next.js 14 Tutorial - 40 - Redirects in Route Handlers

* If id is greater than the number of comments, then redirect to the comments page

** route.tsx **
"
export async function GET(request: Request, { params }: { params: { id: string } }) {
    const { id } = await params;
    if (parseInt(id) > comments.length) {
        redirect("/comments");
    }
    const comment = comments.find((comment) => comment.id === parseInt(id));
    return new Response(JSON.stringify(comment), { status: 200 });
}
"

#? Next.js 14 Tutorial - 41 - Headers in Route Handlers

** profile/route.tsx **
"
import { NextRequest } from "next/server";
import { headers } from "next/headers";

export async function GET(request: NextRequest) {
    //! Approacch 1 to access the headers
    const requestHeaders = new Headers(request.headers);
    console.log(requestHeaders);
    console.log(requestHeaders.get("Authorization"));

    console.log("---------------------------------------------------------------------------");

    //! Approacch 2 to access the headers
    // const headersList = await headers();
    const headersList = headers();
    console.log(headersList);
    // console.log(headersList.get("Authorization"));

    return new Response("<h1>Profile API Data</h1>", {
        status: 200,
        headers: { "Content-Type": "text/html" }
      });
} 
"

#? Next.js 14 Tutorial - 42 - Cookies in Route Handlers

** profile/route.tsx **
"
import { NextRequest } from "next/server";
import { headers, cookies } from "next/headers";
// export async function GET() {
//     return new Response("Profile API Data", { status: 200 });
// }

export async function GET(request: NextRequest) {
  //! Approach 1 to access the headers
  const requestHeaders = new Headers(request.headers);

  const cookie = requestHeaders.get("Cookie");
  console.log(cookie);
  console.log("-----------------------------");

  const theme = request.cookies.get("theme");
  console.log(theme);
  console.log("-----------------------------");

  //! Approach 2 to access the headers
  const cookieStore = await cookies();
  cookieStore.set("resultsPerPage", "10");

  console.log(cookieStore.getAll());

  return new Response("<h1>Profile API Data</h1>", {
    status: 200,
    headers: { 
      "Content-Type": "text/html",
      "Set-Cookie": "user=John Doe, theme=dark",
    },
  });
}
"

#? Next.js 14 Tutorial - 43 - Caching in Route Handlers

* Caching was a default behaviour in Next.js 14 but it is now configurable in Next.js 15

#! Approach 1
** time/route.tsx **
"
export async function GET() {
    return new Response(new Date().toISOString(), {
      status: 200,
      headers: {
        "Content-Type": "text/plain",
        "Cache-Control": "max-age=3600", // cache for 1 hour
      },
    });
  }
"

#! Approach 2
** time/route.tsx **
"
import { NextResponse } from 'next/server';

export async function GET() {
  const response = new NextResponse(new Date().toISOString());
  response.cache({
    maxAge: 3600, // cache for 1 hour
  });
  return response;
}
"

#? Next.js 14 Tutorial - 44 - Middleware

* Create a middleware.ts file in the src folder

* There are 2 ways to use middleware
a) custom matcher config
b) conditional statement

** custom matcher config
"
//! Approach 1 (using matcher config)
import { NextResponse, NextRequest } from "next/server";

export function middleware(request: NextRequest) {
    return NextResponse.redirect(new URL("/", request.url));
}

export const config = {
    matcher: "/profile",
};
"

** conditional statement
"
//! Approach 2 
import { NextResponse, NextRequest } from "next/server";

export function middleware(request: NextRequest) {
    if (request.nextUrl.pathname === "/profile")
    {
        return NextResponse.redirect(new URL("/hello", request.url));
    }
}
"

#? Next.js 14 Tutorial - 45 - Rendering

* Rendering is the process that transforms the code you write into user interfaces.
* In Next.js, choosing the right time and place to do this rendering is vital for building a performant application.
* CSR, SSR and RSCs
* Rendering in React → Rendering in Next.js
* If you don't fully understand something in a video, try watching it again, maybe even a third time.

#? Next.js 14 Tutorial - 46 - Client-side Rendering (CSR)

* Client-side rendering is the process of rendering the entire application on the client-side.
* It involves loading and rendering the entire application using JavaScript.    

#? Next.js 14 Tutorial - 47 - Server-side Rendering (SSR)

* Server-side rendering is the process of rendering the entire application on the server-side.
* It uses server-side code to generate the HTML and JavaScript that is then sent to the client.
* Hydration is the process of matching the server-rendered HTML with the client-side DOM to ensure a smooth transition between the two. This happens before the initial content is loaded into the DOM.

#? Next.js 14 Tutorial - 48 - Suspense for SSR

* Refer video and refer images
* Using Suspense for SSR helps us solve various major issues from SSR.

#? Next.js 14 Tutorial - 49 - React Server Components (RSC)

* Next.js has its app router build on the architecture of RSC(React Server Components)

**RSC Key Takeaways**

* RSC introduce a new way of building React apps by separating components into two types: Server Components and Client Components

* Server Components run only on the server, accessing data and preparing content without being sent to the browser, which makes the app faster for users because less information needs to download

* They can't manage clicks or interactions directly

* Client Components, on the other hand, work in the user's browser and handle all the interactive parts of the app, like clicking and typing

* They can also be rendered on the server for a fast initial load of the site. This setup helps make websites faster, more secure, and easier for everyone to use, no matter where they are or what device they're using.

#? Next.js 14 Tutorial - 50 - Server and Client Components

* By default, every component in Next.js is a server component.
* In the src/app, create a about folder and a page.tsx inside it.

#! console.log gives message in terminal means the component is server side component by default
** about/page.tsx **
"
export default function AboutPage() {
    console.log("About Page Server Component"); // This will show this message in the code editors terminal, which will signify that this is a server component
    return <h1>About Page</h1>
}
"

* In the src/app, create a dashboard folder and a page.tsx inside it.

#! console.log gives message in browser console means the component is a client side component
** dashboard/page.tsx **
"
"use client"

import { useState } from "react"

export default function DashboardPage() {
    console.log("Dashboard Client Component!!!");
    const [name, setName] = useState("");
    return (
        <div>
            <h1>Dashboard Page</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} />
            <p>Hello, {name}! </p>
        </div>
    )
}
"

#? Next.js 14 Tutorial - 51 - RSC Rendering Lifecycle

* Refer Images
Server Rendering Strategies
a) Static Rendering
b) Dynamic Rendering
c) Streaming 

#TODO => READ THIS

a) Production Server:
* Optimized build created once
* Deployed directly
b) Development Server:
* Focuses on developer experience
* Pages pre-rendered for every request
* Frequent rebuilds for changes

#? Next.js 14 Tutorial - 52 - Static Rendering

* Refer Images

#? Next.js 14 Tutorial - 53 - Dynamic Rendering

* Refer Images

#? Next.js 14 Tutorial - 54 - Streaming

* Create a components folder and create product.tsx and reviews.tsx inside it.
** components/product.tsx **
"
export const Product = async () => {
    await new Promise((resolve) => setTimeout(resolve, 2000));
    return <div>Product</div>;
};
"

** components/reviews.tsx **
"
export const Review = async () => {
    await new Promise((resolve) => setTimeout(resolve, 4000));
    return <div>Review</div>;
};
"
* In the src/app, create a product-detail folder and a page.tsx inside it.
** product-detail/page.tsx **
"
import { Suspense } from "react";

import { Product } from "../components/product";
import { Review } from "../components/reviews";

export default function ProductDetailPage() {
  return (
    <>
      <div>Product Detail Page</div>
      <Suspense fallback={<div>Loading Product...</div>}>
        <Product />
      </Suspense>
      <Suspense fallback={<div>Loading Review...</div>}>
        <Review />
      </Suspense>
    </>
  );
}
"

#? Next.js 14 Tutorial - 56 - Server-only Code

* "server-only" npm package provides a build in error mechanism if the developer accidently import one of the server modules to client side.
* pip install server-only

* Create a utils folder and a server-utils.ts file
** server-utils.ts **
"
import "server-only"

export const serverSideFunction = () => {
  console.log(
    `use multiple libraries, use env variables, interact with a database, process confidential information`
  );
  return "server result";
};
"

* Create src/app/server-route folder with a page.tsx in it.
** server-route/page.tsx **
"
import { serverSideFunction } from "../utils/server-utils";

export default function ServerRoutePage() {
  console.log("Server Route Rendered");
  const result = serverSideFunction();
  return (
    <>
      <h1>Server Route Page...</h1>
      <p>{result}</p>
    </>
  );
}
"

* Create src/app/client-route folder with a page.tsx in it.
** client-route/page.tsx **
"
"use client"
import { serverSideFunction } from "../utils/server-utils";

export default function ClientRoutePage() {
    console.log("Client Route Rendered");
    const result = serverSideFunction();
    return (
      <>
        <h1>Client Route Page...</h1>
        <p>{result}</p>
      </>
    );
  }
"

// This will give error as serverSideFunction is allowed only for server components because we used server-only in that file
Error:
"
./src/app/utils/server-utils.ts:1:1
Ecmascript file had an error
> 1 | import "server-only"
    | ^^^^^^^^^^^^^^^^^^^^
  2 |
  3 | export const serverSideFunction = () => {
  4 |   console.log(

You're importing a component that needs "server-only". That only works in a Server Component but one of its parents is marked with "use client", so it's a Client Component.
Learn more: https://nextjs.org/docs/getting-started/react-essentials
"

#? Next.js 14 Tutorial - 57 - Third Party Packages

* Watch video and refer images. There's a issue with the package version at the moment.

#? Next.js 14 Tutorial - 58 - Context Providers

* Create a provider file which will provide the context for any component. Create a theme-provider.tsx file in src/app/components folder.
** theme-provider.tsx **
"
"use client";

import { createContext, useContext } from "react";

type Theme = {
  colors: {
    primary: string;
    secondary: string;
  };
};

const defaultTheme: Theme = {
  colors: {
    primary: "red",
    secondary: "blue",
  },
};

const ThemeContext = createContext<Theme>(defaultTheme);

export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <ThemeContext.Provider value={defaultTheme}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);
"
* Now wrap this ThemeProvider to the body of the RootLayout component.
** app/layout.tsx **
"
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <ThemeProvider>
        <body
          className={`${geistSans.variable} ${geistMono.variable} antialiased`}
        >
          {children}
        </body>
      </ThemeProvider>
    </html>
  );
}
"

* Now use this context in any component. For example in page.tsx of the app folder.
** page.tsx **
"
"use client"
// import { serverSideFunction } from "../utils/server-utils";
import { useTheme } from "../components/theme-provider";

export default function ClientRoutePage() {
    console.log("Client Route Rendered");
    // const result = serverSideFunction();
    return (
      <>
        <h1 style={{ color: useTheme().colors.primary }}>Client Route Page...</h1>
        {/* <p>{result}</p> */}
      </>
    );
  }
"

#? Next.js 14 Tutorial - 59 - Client-only Code

* Create a utils folder and a client-utils.ts file
** client-utils.ts **
"
import "client-only";

export const clientSideFunction = () => {
    console.log(`use window object, use locat storage`);
    return "client result";
}
"

* Create src/app/client-route folder with a page.tsx in it.
** client-route/page.tsx **
"
"use client";
import { clientSideFunction } from "../utils/client-utils";

export default function ClientRoutePage() {
  console.log("Client Route Rendered");
  const result = clientSideFunction();
  return (
    <>
      <h1>Client Route Page...</h1>
      <p>{result}</p>
    </>
  );
}

"